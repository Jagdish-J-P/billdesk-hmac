<?php

namespace JagdishJP\BilldeskHmac\Messages;

use Illuminate\Support\Facades\Config;
use Illuminate\Support\Str;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\ClientException;
use GuzzleHttp\Psr7\Request;
use Illuminate\Support\Facades\Log;
use JagdishJP\BilldeskHmac\Constant\Constants;
use JagdishJP\BilldeskHmac\Constant\Response;
use JagdishJP\BilldeskHmac\Models\Transaction;
use JagdishJP\BilldeskHmac\Traits\Encryption;
use Jose\Component\Core\AlgorithmManager;
use Jose\Component\KeyManagement\JWKFactory;
use Jose\Component\Signature\Algorithm\HS256;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Jose\Component\Signature\JWSBuilder;
use Jose\Component\Signature\JWSVerifier;

class Message
{
    use Encryption;

    public const NA_FIELD     = 'NA';

    /** Transaction Id For Each Payment */
    public $id;


    /** Security Key provided by BILLDESK */
    public $clientId;

    /** Merchant ID provided by BILLDESK */
    public $merchantId;

    /** HMAC Key provided by BILLDESK */
    public $hmacKey;

    /** UAT Prefix provided by BILLDESK */
    public $uatPrefix;

    /** Currency */
    public $currency;

    /** Total amount to be paid */
    public $amount;
    public $refundAmount;

    /** datetime of the transaction in YYYYMMDDHHmmSS format */
    public $order_date;

    /** Transaction Id generated by BILLDESK on each transaction */
    public $transaction_id;
    public $refund_transaction_id;

    /** datetime of the transaction generate from BILLDESK in YYYYMMDDHH24MISS */
    public $transaction_date;

    /** Reference Number used to reference the transaction */
    public $reference;
    public $refundReference;

    /** Additional Info */
    public $additionalInfo;

    /** Response Url */
    public $ResponseUrl;

    /** Item Code */
    public $item_code;

    /** Recurrence Rule */
    public $recurrence_rule;

    /** Debit Day */
    public $debit_day;

    /** Mandate Required */
    public $mandate_required;

    /** Settlement line of business */
    public $settlement_lob;

    /** mandate object */
    public $mandate;

    /** customer object */
    public $customer;

    /** device object */
    public $device;

    /** invoice object */
    public $invoice;

    /** Transaction response status sent by BILLDESK */
    public $transactionStatus;
    public $errorMessage;

    /** Checksum key */
    public $checksumKey;

    /** Response checksum */
    public $checksum;

    /** BIlldesk Response */
    public $responseFormat;

    /** BIlldesk Response */
    public $response;

    /** Billdesk response keys */
    public $responseKeys;

    /** Billdesk Query response keys */
    public $queryResponseKeys;

    /** Billdesk response values */
    public $responseValues;

    public $objectid;

    /** payload */
    public $payload;

    /** jweHelper */
    public $jweHelper;
    public $signAlgoManager;
    public $clientJwk;
    public $jwsBuilder;
    public $jwsVerifier;
    public $jwsSerializer;

    public function __construct()
    {
        $this->id           = $this->generate_uuid();

        $this->merchantId   = Config::get('billdesk.merchant_id');
        $this->clientId     = Config::get('billdesk.client_id');
        $this->hmacKey      = Config::get('billdesk.hmac_key');
        $this->uatPrefix    = Config::get('billdesk.uat_prefix');
        $this->currency     = Config::get('billdesk.currency');

        $this->signAlgoManager = new AlgorithmManager([
            new HS256()
        ]);

        $this->clientJwk     = JWKFactory::createFromSecret($this->hmacKey);
        $this->jwsBuilder    = new JWSBuilder($this->signAlgoManager);
        $this->jwsVerifier   = new JWSVerifier($this->signAlgoManager);
        $this->jwsSerializer = new CompactSerializer();

        $this->item_code    = config('billdesk.item_code');
        $this->ResponseUrl  = config('billdesk.response_url') . '/' . $this->id;

        $this->device = [
            'init_channel' => config('billdesk.init_channel'),
            'ip'           => request()->ip(),
            'user_agent'   => request()->header('user-agent'),
        ];
    }

    public function generate_uuid()
    {
        do {
            $uuid = Str::uuid()->toString();
        } while (Transaction::where('unique_id', $uuid)->first());

        return $uuid;
    }

    public function api($url, $request, $headers = [])
    {

        if (empty($headers[Constants::HEADER_BD_TRACE_ID])) {
            $headers[Constants::HEADER_BD_TRACE_ID] = uniqid();
        }

        $bdTraceid = $headers[Constants::HEADER_BD_TRACE_ID];

        if (empty($headers[Constants::HEADER_BD_TIMESTAMP])) {
            $headers[Constants::HEADER_BD_TIMESTAMP] = now()->format('YmdHis');
        }

        $bdTimestamp = $headers[Constants::HEADER_BD_TIMESTAMP];

        $headers["Content-Type"] = "application/jose";
        $headers["Accept"] = "application/jose";

        $requestJson = json_encode($request);

        $token = $this->encryptAndSign($requestJson, [
            Constants::JWE_HEADER_CLIENTID => $this->clientId
        ]);

        Log::channel('daily')->debug('api-log', ['url' => $url, 'request' => $request, 'headers' => $headers, 'token' => $token]);

        try {
            $client        = new Client();
            $request       = new Request("POST", $url, $headers, $token);
            $response      = $client->send($request);
            $responseToken = $response->getBody()->getContents();
        } catch (ClientException $e) {
            $response = $e->getResponse();

            $arr = ['error' => $e->getMessage(), 'response' => $e->getResponse()->getBody()->getContents()];
            Log::channel('daily')->debug('api-response', $arr);
            $responseToken = $arr['response'];
        }

        $responseBody = $this->verifyAndDecrypt($responseToken);

        return new Response($response->getStatusCode(), $responseBody, $bdTraceid, $bdTimestamp);
    }

    /**
     * Get header from object.
     *
     * @return object
     */
    protected function getHeaders($response, $method = 'POST')
    {
        return collect($response->links)->filter(fn ($arr) => $arr->method == $method)->first();
    }
}
